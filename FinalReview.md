# 20-秋-数据结构与算法

> ### Ver. 南京大学软件学院
>
> ### Powered by YDJSIR



# 基本要求

## 代码相关

### 大题Java/C++

### 小题里面他给的是什么就是什么（Java优先）

### 要读得懂代码



## 期末占比

非常高，请各位同学耗子尾汁，好好复习，不要翻车



# 基本算法思想

## 递归

通过重复将问题分解为同类的子问题而解决问题。

#### 出现场景

渗透全课程



## 贪心（注意和动态规划的区别）

在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择。

#### 出现场景

Prim、Kruskal、Dijkstra



## 动态规划（注意和贪心的区别）

通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其[记忆化](https://zh.wikipedia.org/wiki/记忆化)存储，以便下次需要同一个子问题解之时直接查表。

> ### 动态规划中不应该有“回溯”，那样就类似于打表了

#### 出现场景

Bellman-Ford



## 分治

#### 出现场景

归并排序



# 本文档说明

> ==高亮== 表示这是一个算法的名字。
>
> 

本文档基本上整理自课件，结合了部分在线资源，参考资料将被尽量详细地列出。如果这其中的内容侵犯了您的知识产权，请及时与YDJSIR联系，YDJSIR会尽量及时响应。



# 第一章 概论

略掉，要求理解，重点在选择题。

### Data_Structure={D,R}; D: Data Object; R: Relationship

## 三个方面

#### 数据的逻辑结构

从用户视图看，是面向问题的。 

#### 数据的物理结构

从具体实现视图看，是面向计算机的。 

#### 数据结构相关的操作及其实现

#### ADT：Abstract data type——封装

#### Java & C++ Basics

#### OO



# 第二章 算法分析

## 复杂度计算！（空间 & 时间）

> ### 运行时细节（栈空间、堆空间）不考

一般是计算运行次数和给出算法的量级这样的形式。

### 最好情况、最坏情况、平均情况

算法旁边标注的都是最大复杂度。

#### O - 上限

#### Ω - 下限

#### θ - 上下限同一个量级



### ==顺序查找== - O(n)

### ==秩排序== - O(n²)

```

```

先把每个元素排第几算出来，然后再把每个元素放到该放的位置

### ==选择排序== - O(n²)

```

```

每次都选出最大/最小的元素，然后把它放到前面来

### ==冒泡排序== - O(n²)

```

```

不解释

### ==插入排序== - O(n²)

```

```

不解释

### ==折半查找== - O(log n)

```

```

不解释

### ==辗转相除法==  - O(log n)

```

```

> 它的复杂度的计算不做要求



# 第三和五章 表 - 线性数据结构

## :star: 线性表

> 各种线性表的实现细节与各种操作的复杂度

### （单/双）（循环/非循环）链表

#### 节点

- 数据
- 后指针
- 前指针（仅双链表）

#### 链表

##### 成员变量

- 头

> 注意Dummy Head的存在，而且这还一般在题目中是默认的。
>
> ![image-20201228184045261](C:\Users\YuDongjun\Desktop\NJU\2020-Fall\DataStructureAndAlgorithm\FinalReview.assets\image-20201228184045261.png)

- *头、 *尾

注意链表的一些小技巧，课后习题中便有体现（隐含了归并排序的思想）

> 双链表不是重点



## 栈和队列

他们都是特殊的线性表。它们在功能上受到了更多的限制，以适应于特殊用途。

进去一个元素和出去一个元素都是O(1)

## 栈 - `LIFO`

`push` `pop` `peek`等方法，此处不展开。

内部实现可以是数组和链表，但是都被抽象起来了。

栈可以设定容量，所以可能会满。



## 队列 - `FIFO`

> 显然，这玩意和优先队列的实现是根本不一样的！

`inqueue`  `enqueue` 

队列可以设定容量，所以可能会满。

可以搞循环队列来节约资源。



### ==基数排序== - O(${\displaystyle  \log _{B}\left(N\right)\cdot n}$)

这里的桶实际上是一个FIFO的队列，所以放在这个位置上。

###### 补充

- 基数排序：根据键值的每位数字来分配桶；
- 计数排序：每个桶只存储单一键值；
- 桶排序：每个桶存储一定范围的数值；

比如说对一个十进制数，可以按照这样的顺序来：先按照个位数进桶，然后十位，以此类推，到最后就排好了。



## 哈希表

### 负载因子、再散列

重点是取模算法，其他的反而没那么重要

### 冲突处理！（线性探查，二次探查、双重哈希）



# 第四六七章 :christmas_tree: 树 - 非线性数据结构

## 基本概念与术语

节点、根等

## 二叉树

满二叉树、完全二叉树等，

### 边和点的关系式

### 各种遍历的方式

#### 先序

```

```



#### 中序

```

```



#### 后序

```

```



#### 按层次遍历

```

```



> 以上内容的重点在递归算法，非递归算法（基于栈）重在理解。



### 各种表示二叉树的方式

#### 数组（访问效率高但是不大灵活）

根据索引来定位，这也是堆中的完全二叉树的组织方式

#### 索引

类似链表，较为常用



### 各种建树的方式

#### MakeTree

#### 先序 + 中序 / 后序 + 中序

#### 广义表

#### 后缀表达式



## 树和森林

### 表示法

#### * 广义表

#### 双亲

#### :star: 左子女右兄弟

PS：学会将一棵任意的树转换为二叉树



### 树的遍历

### DFS

#### 先根

> 对应于左子女右兄弟二叉树的`先序`

#### 后根

> 对应于左子女右兄弟二叉树的`中序`

### BFS

#### 按层次遍历



### 森林的遍历

### DFS

#### 先根

> 对应于左子女右兄弟二叉树的`先序`

#### 中根

> 对应于左子女右兄弟二叉树的`中序`

#### 后根

> 对应于左子女右兄弟二叉树的`后序`

### BFS

#### 按层次遍历



### 线段树

#### 节点

| left | left thread         | data | right thread        | right  |
| ---- | ------------------- | ---- | ------------------- | ------ |
| 指针 | 0 - 左子女 1 - 前驱 |      | 0 - 右子女 1 - 后继 | 右指针 |

#### 线索树

在建树的时候左右两个数据域都要填上，然后根据实际情况补充 `left thread` 和 `right thread` 的值。

#### PPT中给了中序线索二叉树的例子



#### 霍夫曼树 - 增长树

霍夫曼编码 - 压缩存储空间、编码二叉树构建



### 字符串

略

### * 广义表



## :star2: 搜索树！

> 各种操作

### 二叉搜索树

一般是左边的key值比根节点小，右边key值的比根节点大



### :flags: AVL树！

自平衡的二叉搜索树！

任何时候，左右子树的高度差不超过1。

搜索复杂度：O(log n) 树高度：O(log n)

#### 单旋转



#### 双旋转



### m路搜索树

类似二叉搜索树，但是每个节点里面可能有多个值

### B树、* B+树

平衡的m叉搜索树

兄弟节点/父子节点之间的合并



## 优先队列 - 堆

只要求父节点key值大于/小于子节点key值的完全搜索二叉树：

### 建堆

#### 自下而上：元素是不断进来的 - O(n)



#### 自上而下：一开始就有所有的元素 - O(log n)



### 堆排序

先



### 优先队列

一个一直维护着的堆，按照优先级大小出队。



### 并查集

重点在使用，一般不单独考察内部具体实现。



# 第八章 :star2: 图 - 非线性数据结构

## 概念理解

各种图、完全图、简单图、路径、连通性

#### 有向图和无向图



## 图的表示

### 邻接矩阵 - 适合高密度的矩阵（节约空间）

### 邻接表 - 适合稀疏矩阵

##### 邻接多重表



## 图的相关算法

### 图的遍历

#### DFS 



#### BFS



#### 邻接表下BFS和DFS都是 O(n+e)

#### 邻接矩阵下BFS和DFS都是O(n²)



### 最小生成树

#### ==Kruskal== - 基于边 - O(n²)



#### ==Prim== - 基于点 - O(n²)



### 最短路径

#### ==Dijkstra== - O(n²) - 无负权值



#### ==Bellman-Ford== - O(n³) - 无负环



#### ==Floyd== - O(n³) - 无负权值 - 所有点到所有点的最短路径



## 图的应用

### AOV & ==拓扑排序== - O(n + e)

AOV网里面不应该出现有向环。用顶点表示活动，可用来表示活动发生顺序。拓扑排序可以检测环路是否存在。

拓扑排序不唯一。



### AOE - O(n + e)

顶点表示时间，有向边表示活动

可以由此得出 `关键活动` `最早发生时间` `最迟发生时间`等



# 第九章 排序

## ==二分法插入排序== ==希尔排序== ==表插入排序== ==快速排序== ==归并排序== 

## 复杂度在下图中

![image-20201228235012862](C:\Users\YuDongjun\Desktop\NJU\2020-Fall\DataStructureAndAlgorithm\FinalReview.assets\image-20201228235012862.png)

![image-20201228235033075](C:\Users\YuDongjun\Desktop\NJU\2020-Fall\DataStructureAndAlgorithm\FinalReview.assets\image-20201228235033075.png)

